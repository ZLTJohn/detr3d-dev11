# Importing necessary libraries
import networkx as nx
import numpy as np
# Creating a graph
G = nx.Graph()

# Adding edges to the graph
G.add_edge(0, 1, weight=4)
G.add_edge(1, 2, weight=8)
G.add_edge(2, 3, weight=7)
G.add_edge(3, 4, weight=9)
G.add_edge(4, 5, weight=10)
G.add_edge(5, 6, weight=2)
G.add_edge(6, 7, weight=1)
G.add_edge(7, 0, weight=1)
G.add_edge(7, 1, weight=1)
G.add_edge(7, 8, weight=7)
G.add_edge(8, 2, weight=2)
G.add_edge(8, 6, weight=6)
G.add_edge(8, 3, weight=4)
# print(G.edges.data('weight'))
def get_root(father, node):
    if father[node] == node:
        return node
    father[node] = get_root(father, father[node])
    return father[node]

def custom_kruskal(G: nx.Graph, mn_degree=2):
    '''
    Theoratically O(mlogn)
    '''
    edges = G.edges.data('weight')
    edges = sorted(edges, key=lambda x: x[2])# reverse = True
    father = np.array([i for i in G.nodes()])
    degree = np.zeros(len(G.nodes))
    mst_graph = nx.Graph()
    for edge in edges:
        node1, node2, weight = edge
        if degree[node1] == 2 or degree[node2] == 2:
            continue
        rt1 = get_root(father, node1)
        rt2 = get_root(father, node2)
        if rt1==rt2:
            continue
        father[rt2] = rt1
        degree[node1]+=1
        degree[node2]+=1
        mst_graph.add_edge(node1, node2, weight=weight)
    return mst_graph
mst = custom_kruskal(G)
print(mst.edges)

def kruskal_algorithm(graph):
    '''
    Theoratically O(mnlogn), generated by chatGPT
    '''
    # Create a set for each node in the graph
    sets = [{node} for node in graph.nodes()]
    
    # Sort the edges in the graph by weight
    sorted_edges = sorted(graph.edges(data=True), key=lambda x: x[2]['weight'])
    degree = np.zeros(len(G.nodes))
    # Create an empty list to store the edges in the minimum spanning tree
    mst = []
    
    # Iterate through the sorted edges
    for edge in sorted_edges:
        # Get the nodes that the edge connects
        node1, node2, weight = edge
        if degree[node1] == 2 or degree[node2] == 2:
            continue
        # Find the set that each node belongs to
        set1 = None
        set2 = None
        for s in sets:
            if node1 in s:
                set1 = s
            if node2 in s:
                set2 = s
        
        # If the nodes are in different sets, add the edge to the minimum spanning tree
        if set1 != set2:
            mst.append(edge)
            
            # Merge the sets
            set1.update(set2)
            sets.remove(set2)
    
    # Create a new graph for the minimum spanning tree
    mst_graph = nx.Graph()
    
    # Add the nodes to the new graph
    for node in graph.nodes():
        mst_graph.add_node(node)
    
    # Add the edges to the new graph
    for edge in mst:
        node1, node2, weight = edge
        mst_graph.add_edge(node1, node2, weight=weight['weight'])
    
    # Return the minimum spanning tree graph
    return mst_graph
# # Finding the minimum spanning tree using Kruskal's algorithm
# T = nx.minimum_spanning_tree(G)

# # Removing edges from the minimum spanning tree that exceed 2 degree
# for node in T.nodes():
#     edges = T.edges(node, data=True)
#     if len(edges) > 2:
#         edges = sorted(edges, key=lambda x: x[2]['weight'])
#         T.remove_edge(edges[-1][0], edges[-1][1])

# # Printing the edges of the minimum spanning tree
# print(sorted(T.edges(data=True)))
